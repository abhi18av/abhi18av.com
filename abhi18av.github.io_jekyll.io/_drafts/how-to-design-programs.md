---
layout: post
title: How to Design Programs
---


Programming, as I've come to understand it, is an art of understanding systems, modelling behaviours. It's not enough to just get the job done but we must strive for creating programs which are evolutionarily fit! 

Code that get stronger with every iteration, every adaptation. The Code which is meant to be there for a long haul, I feel, should be more like the work of an architect adn not a bunch of patchwork with an initial codebase.


These are the toughts which have driven me towards simplicity - my need to improve the way I understand programming and to overcome the sheer dread of having to solve the problem again by slogging through a codebase ( even my own! ) to create a change. 

Computation as it began is much like it's godfather, Mathematics but in addition to the appreciation of elegant problem solving, it also requires to have certain design aesthetics.

I've heard/read over and over again how wonderful the book "Structure and Interpretation of Computer Programs" is and I'm in complete agreement with that but I've never really been able to make a proper slog through the book in the first place. I mostly give up towards the end of second chapter and then ages later, when I do return with my hopeful eyes to "get through with the book finally", the same thing happens again. I guess the biggest problem is not having a similar *simple* scheme implementation to really accompany the book.

Eventually it all just boils down to trying to translate the book into Racket or Clojure and it's turtles all the way down from there. 

I would say that even if SCIP is the most enlightening experience in a programming language I'd much rather stick with something which I can apply, which is more of an investment than an intellectual exploration. It's not without reason that "Programming is the same as applied Mathematics, occasionaly flirting with Pure Foundations as well". There's an innate drive in programming to *use* what we have learned.


If there's anyone out there who's stuck with such a dilemma, trust me you don't need to look any further than *How to Design Programs* - Felleisen et al. This is one of hte most profound books I've read which doesn't drown the beauty of programming and computing in to syntactical barrage or language oriented peculiarities rather, this books really sticks to a minimum of syntactical sugar and rapidly takes on the most dreaded programming technique for a novice programmer - Recursion.



