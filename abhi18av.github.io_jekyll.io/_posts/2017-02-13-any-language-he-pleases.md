---
title: Any Language he pleases
layout: post
date: 2017-02-13 20:00
image: 
description: Programming and Languages
tag: 
  - Computation
  - ProgLangs
blog: true
jemoji:
author: Abhinav Sharma
---

>> Give a man Fortran, he has Fortran.

>> Give a man Lisp, he has any language he pleases! - Guy Steele 


I'd say that my drive and search for a good, enabling tool (not perfect, it's a myth :) ) is hardly over. I've been living in *confusion* regarding the variety of languages
there is and experimenting with the strength and weaknesses of each language - I've become an avid coder on Github. But I honestly feel ... I haven't still realized what 
exactly I need to understand computation and become competent in programming.

Haskell and Clojure have had a profound impact on my way of approaching programming and made me realize that being mathematically sound and adaptability is something that 
we must cherish. At the same time, I'm definitly in love with Julia for it's balancing act between different worlds and paradigms of programming a brainchild of programming 
language research, scientific computing and practical engineering. And as I've mentioned in my previous posts, it's not only about these few languages - I've also dabbled quite 
substantially in F# and C#, not to forget the venerable Anaconda (python) and who can really overlook JavaScript in out times.

Thing is, each language has something that doesn't suit my needs or to be blunt, has something that makes me itchy. Be it lack of tail call optimization, typeclasses, dependent types,
mutual recursion or just good enough libraries and community. What's the balance of simplicity and something that enables me to explore computation in a practical way.

I dislike C++ with a certain passion, probably has to do with this language being shoved down the throat of young and innocent programmers. C is definitely tolerable and even a 
necessary evil when it comes to High performance computing. My domain being Linguistics and my nature being less of an engineer and more of an explorer in computing, this is a
recipe for definite confusion :P

I'd say that if Racket (Scheme) had more mature libraries or a better Clojure like community/tooling, it'd be my dream language. 

Why do I call a minute language - ideal?

The reason being it's Lisp DNA and the amazing work done by the community in terms of Type Systems, be it
  - Dependent Types
  - Haskell like Hindley-Milner types
  - F* like Higher Kinded types for SAT
  - Prolog like programming
  - Object Oriented Programming
  - Functional Programming
  - Reactive Programming
 
  The community is doing it all and without even altering the syntax much!
  
  When I think about how well do I really understand various paradigms of computing and system architecture, I find myself terribly lacking in understanding 
  of not only the basics of Algorithms and Data Structures, System Design but also the very real issues like Compilers, STM, Concurrency, Asynchronous or Reactive programming etc.
  
  I often feel quite demotivated, given this innate need of mine to be able to explore without being tied down by pradigms. I know I'd have to dabble in a multitude of languages and
  paradigms but I'd atleast make it *Simple* through Racket and I'd scale it to my needs through Go-lang. Both of these languages have ambient stillness about them, calmness
  about having done the best they could to facilitate their brand of paradigms and while keeping it all simple and approachable. 
  
  As for my education in other fields and paradigms, I've been give Financial Aid in a few Coursera courses ranging from Bioinformatics to 
  Game Design and Web Development, I'd of course complete the courses in these fields as per the requirements of the courses but for my own, 
  I'd work on just two languages, tying them together as tightly as possible - Scheme(Racket) and Go.
