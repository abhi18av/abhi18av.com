<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"><link href="/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"><link href="/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/manifest.json" rel="manifest"><link color="#5bbad5" href="/safari-pinned-tab.svg" rel="mask-icon"><meta content="#ffffff" name="theme-color"><link href="/css/normalize.css" rel="stylesheet"><link href="/css/app.css" rel="stylesheet"><title>a prototype for a function generating macro in Clojure - 200ok</title><link href="/rss.xml" rel="alternate" title="200ok - Consultancy, Research Lab, Incubator" type="application/rss+xml"><link href="/atom.xml" rel="alternate" title="200ok - Consultancy, Research Lab, Incubator" type="application/atom+xml"><meta content="a prototype for a function generating macro in Clojure - 200ok" property="og:title"><meta content="article" property="og:type"><meta property="og:description"><meta content="https://200ok.ch/posts/a-prototype-for-a-function-generating-macro-in-clojure.html" property="og:url"><meta content="https://200ok.ch/img/logo.png" property="og:image"><meta content="summary" name="twitter:card"><meta content="@twohundredok" name="twitter:site"><meta content="a prototype for a function generating macro in Clojure - 200ok" name="twitter:title"><meta content="https://200ok.ch/img/logo.png" name="twitter:image"><meta name="twitter:description"><link href="https://200ok.ch/posts/a-prototype-for-a-function-generating-macro-in-clojure.html" rel="canonical"><link href="/css/styles/solarized-light.css" rel="stylesheet"></head><body id="blog" itemscope itemtype="http://schema.org/Blog"><div class="top-bar"><div class="top-bar-left"><top-bar-title itemprop="image"><a href="/" id="logo"><img src="/img/200ok.svg"></a></top-bar-title></div><div class="top-bar-right"><ul class="menu"><li><a href="/blog.html">Blog</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/team.html">Team</a></li><li><a href="/atom.xml" id="atom-feed"><span>&nbsp;</span>Feed</a></li></ul></div></div><main class="single-post"><div id="content"><article class="blog-post" itemscope itemtype="https://schema.org/BlogPosting"><h3 class="headline" itemprop="headline"><a class="nunito" href="/posts/a-prototype-for-a-function-generating-macro-in-clojure.html" itemprop="url">a prototype for a function generating macro in Clojure</a></h3><div class="subheader"><p class="post-meta"><time itemprop="datePublished">2016-12-10</time> - <span itemprop="wordCount">444</span> words - <span itemprop="timeRequired">3</span> min read</p><div class="byline"><img class="author-icon" src="/img/author.svg"><section class="author" itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="name">Phil Hofmann</span></section></div></div><span itemprop="image" itemscope itemtype="https://schema.org/ImageObject"><meta content="190" itemprop="height"><meta content="349" itemprop="width"><meta content="https://200ok.ch/img/logo.png" itemprop="url"></span><div><div class="article-body" itemprop="articleBody"><p>TL;DR I was looking for a prototype of a Clojure macro that fulfills three requirements: (1) Generates a function. (2) Takes options as parameters and provides those to the generated function. (3) And lastly the generated function takes arguments. Spoiler! This is it…</p>
<pre><code>(defmacro defsample [name &amp; args]
  (let [options (apply hash-map args)]
    `(defn ~name [input#]
       (prn (str (:text ~options) &quot; &quot; input# &quot;.&quot;)))))

(defsample sample :text &quot;Hello&quot;)

(sample &quot;world&quot;)</code></pre>
<p>Keep on reading for a detailed description. In my quest to come up with the prototype above I started with the most basic version of a macro that generates a function.</p>
<pre><code>;; working, but boring

(defmacro defsample [name]
  `(defn ~name []
     (prn &quot;Hello World.&quot;)))

(defsample sample)

(sample)</code></pre>
<p>The key elements of this macro being of course the Syntax Quote <code>`</code> and the Syntax Unquote <code>~</code>.</p>
<p>With a little modification the macro will take options and provide these to the generated function:</p>
<pre><code>;; working, but still somewhat boring

(defmacro defsample [name &amp; args]
  (let [options (apply hash-map args)]
    `(defn ~name []
       (prn (:text ~options)))))

(defsample example :text &quot;Hello world.&quot;)

(example)</code></pre>
<p>Now, if we also want to pass in arguments to the generated function, the straight forward attempt will not work:</p>
<pre><code>;; defunkt!

(defmacro defsample [name]
  `(defn ~name [input]
     (prn input)))

(defsample sample)

(sample &quot;Hello world.&quot;)</code></pre>
<p>The reason that this does not work is, that in the example above the Syntax Quote <code>`</code> will fully qualify all symbols within. But since qualified symbols cannot be used in the params of a <code>defn</code> this will result in a</p>
<pre><code>CompilerException java.lang.RuntimeException: Can&#39;t use qualified name as parameter</code></pre>
<p>So let’s replace the Syntax Quote with a regular Quote <code>'</code> then…</p>
<pre><code>;; also defunkt!

(defmacro defsample [name]
  &#39;(defn ~name [input]
     (prn input)))

(defsample sample)

(sample &quot;Hello world.&quot;)</code></pre>
<p>But, as you might have guessed, using a regular Quote instead of a Syntax Quote doesn’t help, because the Syntax Unquote will not work properly and thus result in a</p>
<pre><code>CompilerException java.lang.IllegalArgumentException: First argument to defn must be a symbol</code></pre>
<p>So instead of using a given symbol, which will be fully qualified by the Syntax Quote, we will have to use a generated symbol. This is anyway a good practice since it will prevent accidental naming collisions. In addition to the function <code>gen-sym</code> which will generate such a generated symbol, there is also a short hand in form of a reader macro, that let’s us mark a symbol as to be replaced with a generated symbol. It works by appending a <code>#</code> to the symbol.</p>
<pre><code>;; working and almost there...

(defmacro defsample [name]
  `(defn ~name [input#]
     (prn input#)))

(defsample sample)

(sample &quot;Hello world.&quot;)</code></pre>
<p>Now, combining this with the macro that took options and we finally arrive at the prototype that you saw in the first paragraph.</p>
</div><div class="tags"><img class="tag-icon" src="/img/tag.svg"><ul itemprop="keywords"><li class="category"><a href="/category/clojure.html">clojure</a></li><li class="tag"><a href="/tags/macro.html">#macro</a></li><li class="tag"><a href="/tags/metaprogramming.html">#metaprogramming</a></li><li class="tag"><a href="/tags/prototype.html">#prototype</a></li></ul></div></div></article></div></main><footer><div itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><div class="name" itemprop="name">200ok GmbH</div><div itemprop="address" itemscope itemtype="https://schema.org/PostalAddress"><a href="https://goo.gl/maps/GNAoiNF7mbL2" title="View on Google Maps"><div itemprop="streetAddress">Badenerstrasse 313</div><div><span itemprop="postalCode">8003</span> <span itemprop="addressLocality">Zürich</span></div></a></div><div itemprop="telephone">+41 76 405 05 67</div><div itemprop="email"><a href="mailto:info@200ok.ch">info@200ok.ch</a></div><img itemprop="logo" src="https://200ok.ch/img/200ok.svg"></div></footer><div class="scripts" style="{:display &quot;none&quot;}"><script src="/js/vendor/bowser.min.js"></script><script async src="/js/ie_safeguard.js"></script><script async src="/js/tour.js"></script><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>tour=null</script></div></body></html>